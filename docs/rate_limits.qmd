---
title: "Rate Limits"
---

## API Rate Management

The IMF API imposes very restrictive (and incompletely documented) rate limits, not only for individual users and applications, but also globally for all users of the API. Thus, at high-traffic times, you may find that your requests fail. It's highly recommended that you set up proactive error handling, wait times, retries, and request caching to avoid hitting the API's rate limits. The `imfp` library provides some tools to help you do this (with more planned for future releases).

### Setting Application Name

The IMF API has an application-based rate limit of 50 requests per second. Each application is identified by the "user_agent" variable in the request header. By default, all `imfp` users share the same application name, which could lead to rate limit issues if many users are making requests simultaneously.

This could prove problematic if the `imfp` library became too popular and too many users tried to make simultaneous API requests using the default app name. By setting a custom application name, users can avoid hitting this rate limit and being blocked by the API. To solve this problem, `imfp` supplies the `set_imf_app_name()` function to set a custom application name.

`imfp.set_imf_app_name()` sets the application name by changing the `IMF_APP_NAME` variable in the environment. If this variable doesn't exist, `imfp.set_imf_app_name()` will create it. To set a custom application name, simply call the `imfp.set_imf_app_name()` function with your desired application name as an argument:

``` {python}
# Set custom app name as an environment variable
imfp.set_imf_app_name("my_custom_app_name")
```

The function will throw an error if the provided name is missing, NULL, NA, not a string, or longer than 255 characters. If the provided name is "imfp" (the default) or an empty string, the function will issue a warning recommending the use of a unique app name to avoid hitting rate limits.

### Managing Request Timing

If making multiple requests in a short period of time, you may want to increase the wait time between requests to avoid hitting the API's rate limits. This is done with the `set_imf_wait_time()` function:

``` {python}
# Default 1.5 second wait between calls
imfp.set_imf_wait_time(1.5)

# Increase wait time for parallel processing
imfp.set_imf_wait_time(5)
```

### Retries

`imfp` automatically handles rate limits with exponential backoff:

1. Waits for specified time
2. Retries the request
3. Increases wait time exponentially on subsequent failures
4. Stops after 3 attempts (default)

You can modify retry behavior:

``` {python}
# Custom retry settings (not recommended above 3)
df = imfp.imf_dataset("IFS", times=3)
```

### Caching Strategy

To reduce API calls, you can cache frequently accessed data. For instance, in a Jupyter or Quarto notebook that you run multiple times, you can wrap each `imfp` function call in an `if` statement that checks if the returned data has already been saved to a file. If it has, it loads the data from the file. If it hasn't, it fetches the data from the API and saves it to a file.

``` {python}
# Fetch imf databases from file if available, else from API
cache_path = f"data/imf_databases.parquet"
if os.path.exists(cache_path):
    databases = pd.read_parquet(cache_path)
else:
    databases = imfp.imf_databases()
    os.makedirs("data", exist_ok=True)
    databases.to_parquet(cache_path)
```

You can also functionalize this logic to permit reuse several times in the same script or notebook. See Jenny Xu's excellent [demo notebook](demo.qmd#utility-functions) for example caching functions.

## Performance Tips

1. **Filter Early**: Use parameters to limit data at the API level
2. **Parallelize Carefully**: Avoid running parallel API requests, even from multiple clients
3. **Use Efficient Formats**: Store cached data in parquet or feather files
4. **Validate Data**: Check for errors and empty responses

## Understanding IMF API Rate Limits

The IMF API has an application-based rate limit of 50 requests per second. Each application is identified by the "user_agent" variable in the request header. By default, all `imfp` users share the same application name, which could lead to rate limit issues if many users are making requests simultaneously.

## Setting a Custom Application Name

To avoid hitting rate limits, you should set a unique application name for your requests:

``` {python}
imfp.set_imf_app_name("my_custom_app_name")
```

The `set_imf_app_name()` function:
- Sets the application name in the `IMF_APP_NAME` environment variable
- Creates the variable if it doesn't exist
- Validates that the name is:
  - Not missing
  - A string
  - Less than 255 characters
  - Not the default "imfr" name

## Managing Wait Times Between Calls

By default, `imfp`:

- Enforces a 1.5-second wait between API calls
- Retries failed calls up to 3 times
- Uses exponential backoff starting at 5 seconds for retries

This wait time should be sufficient for most applications. However, if you are running parallel processes using `imfp` (e.g. during cross-platform testing), this wait time may be insufficient to prevent you from running up against the API's rate and bandwidth limits.

If you're experiencing rate limit issues, try increasing the wait time by calling `set_imf_wait_time()` with the desired wait time in seconds:

``` {python}
# Set a 5-second wait time between calls
imfp.set_imf_wait_time(5)
```

## Best Practices

1. **Use a Unique App Name**: Always set a custom application name for your project
2. **Filter Requests**: Use parameters to limit the data you're requesting
3. **Batch Processing**: For large datasets, consider breaking requests into smaller batches
4. **Monitor Responses**: Watch for rate limit errors and adjust wait times if needed
5. **Parallel Processing**: If running parallel processes, increase the wait time accordingly

## Error Handling

When a rate limit is hit, `imfp`:
1. Automatically waits for the specified time
2. Retries the request
3. Increases wait time exponentially on subsequent failures
4. Stops after 3 attempts (by default)

You can modify retry behavior by setting the `times` argument in API calls, though increasing it beyond 3 is not recommended due to the exponential backoff.
