---
title: "Suggestions for Usage"
---

## Working with Large Data Frames

### Inspecting Data

`imfp` outputs data in `pandas` DataFrames, so you will want to use the `pandas` package for its functions for viewing and manipulating this object type.

For large datasets, you can use the `pandas` library's `info()` method to get a quick summary of the data frame, including the number of rows and columns, the count of non-missing values, the column names, and the data types.

``` {python}
import imfp
import pandas as pd

df: pd.DataFrame = imfp.imf_dataset(
    database_id="PCPS",
    commodity=["PCOAL"],
    unit_measure=["IX"],
    start_year=2000, end_year=2001
)

# Quick summary of DataFrame
df.info()
```

Alternatively, you can use the `head()` method to view the first 5 rows of the data frame.

``` {python}
# View first 5 rows of DataFrame
df.head()
```

### Cleaning Data

All data is returned from the IMF API as a text (object) data type, so you will want to cast numeric columns to numeric.

``` {python}
# Numeric columns
numeric_cols = ["unit_mult", "obs_value"]

# Cast numeric columns
df: pd.DataFrame = df.to_numeric(numeric_cols)
```

You can also convert string columns to categorical types for better memory usage.
``` {python}
# Convert categorical columns like ref_area and indicator to category type
# This reduces memory usage for columns with repeated string values
categorical_cols = ["ref_area", "indicator", "unit_measure"]
df[categorical_cols] = df[categorical_cols].astype("category")
```

After conversion, you may want to drop any rows with missing values.

``` {python}
# Drop rows with missing values
df = df.dropna()
```

The `time_period` column can be more difficult to work with, because it may be differently formatted depending on the frequency of the data.

Annual data will be formatted as a four-digit year, such as "2000", which can be trivially converted to numeric.

However, quarterly data will be formatted as "2000-Q1", and monthly data will be formatted like "2000-01".

You can use the `pandas` library's `to_datetime()` method with the `format="mixed"` argument to convert this column to a datetime object in a format-agnostic way:

``` {python}
# Convert time_period to datetime
print(pd.to_datetime(df["time_period"], format="mixed").head())
```

Alternatively, you can split the `time_period` column into separate columns for year, quarter, and month, and then convert each to a numeric value:

``` {python}
# Split time_period into separate columns
df["year"] = df["time_period"].str.extract(r"(\d{4})")[0]
df["quarter"] = df["time_period"].str.extract(r"Q(\d{1})")[0]
df["month"] = df["time_period"].str.extract(r"-(\d{2})")[0]

# Convert year, quarter, and month to numeric
df["year"] = pd.to_numeric(df["year"])
df["quarter"] = pd.to_numeric(df["quarter"])
df["month"] = pd.to_numeric(df["month"])

print(df[["time_period", "year", "quarter", "month"]].head(5))
```

### Summarizing Data

After converting columns to numeric, you can use the `describe()` function to get a quick summary of the statistical properties of these, including the count of rows, the mean, the standard deviation, the minimum and maximum values, and the quartiles.

``` {python}
# Statistical summary
df.describe()
```

### Viewing Data

For large data frames, it can be useful to view the data in a browser window. To facilitate this, you can define a `View()` function as follows. This function will save the data frame to a temporary HTML file and open it in your default web browser.

``` {python}
#| eval: false
import tempfile
import webbrowser

# Define a simple function to view data frame in a browser window
def View(df: pd.DataFrame):
    html = df.to_html()
    with tempfile.NamedTemporaryFile('w', 
    delete=False, suffix='.html') as f:
        url = 'file://' + f.name
        f.write(html)
    webbrowser.open(url)

# Call the function
View(df)
```
