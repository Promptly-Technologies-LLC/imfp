{"title":"imfp Demo Project","markdown":{"yaml":{"title":"imfp Demo Project"},"headingText":"Executive Summary","containsRefs":false,"markdown":"\n\nThis data analysis project aims to explore the relationship between economic growth and gender equality using `imfp`, which allows us to download data from IMF (International Monetary Fund). `imfp` can be integrated with other python tools to streamline the computational process. To demonstrate its functionality, the project experimented with a variety of visualization and analysis methods. \n\n\nIn this project, we explored the following:\n\n1. **Data Fetching**\n* Make API call to fetch 4 datasets: GII (Gender Inequality Index), Nominal GDP, GDP Deflator Index, Population series\n\n2. **Feature Engineering**\n* Cleaning: Convert GDP Deflator Index to a yearly basis and variables to numeric\n* Dependent Variable: Percent Change of Gender Inequality Index\n* Independent Variable: Percent Change of Real GDP per Capita \n* Transform variables to display magnitude of change \n* Merge the datasets\n\n3. **Data Visualization**\n* Scatterplot\n* Time Series Line Plots\n* Barplot\n* Boxplot\n* Heatmap\n\n4. **Statistical Analysis**\n* Descriptive Statistics\n* Regression Analysis\n* Time Series Analysis\n\n## Suggested packages\nThe integration of other Python tools not only streamlined our computational processes but also ensured consistency across the project.\n\nA custom module is written to simplify the process of making API calls and fetching information with imfp library. `load_or_fetch_databases`, `load_or_fetch_parameters` `load_or_fetch_dataset` load and retreive database, parameters, and dataset from a local or remote source. `view_dataframe_in_browser` displays dataframe in a web browser.\n\n```{python}\nimport os\nimport pickle\nfrom tempfile import NamedTemporaryFile\nimport pandas as pd\nimport imfp\nimport webbrowser\n\n\n# Function to display a DataFrame in a web browser\ndef view_dataframe_in_browser(df):\n    html = df.to_html()\n    with NamedTemporaryFile(delete=False, mode=\"w\", suffix=\".html\") as f:\n        url = \"file://\" + f.name\n        f.write(html)\n    webbrowser.open(url)\n\n\n# Function to load databases from CSV or fetch from API\ndef load_or_fetch_databases():\n    csv_path = os.path.join(\"data\", \"databases.csv\")\n\n    # Try to load from CSV\n    if os.path.exists(csv_path):\n        try:\n            return pd.read_csv(csv_path)\n        except Exception as e:\n            print(f\"Error loading CSV: {e}\")\n\n    # If CSV doesn't exist or couldn't be loaded, fetch from API\n    print(\"Fetching databases from IMF API...\")\n    databases = imfp.imf_databases()\n\n    # Save to CSV for future use\n    databases.to_csv(csv_path, index=False)\n    print(f\"Databases saved to {csv_path}\")\n\n    return databases\n\n\ndef load_or_fetch_parameters(database_name):\n    pickle_path = os.path.join(\"data\", f\"{database_name}.pickle\")\n\n    # Try to load from pickle file\n    if os.path.exists(pickle_path):\n        try:\n            with open(pickle_path, \"rb\") as f:\n                return pickle.load(f)\n        except Exception as e:\n            print(f\"Error loading pickle file: {e}\")\n\n    # If pickle doesn't exist or couldn't be loaded, fetch from API\n    print(f\"Fetching parameters for {database_name} from IMF API...\")\n    parameters = imfp.imf_parameters(database_name)\n\n    # Save to pickle file for future use\n    os.makedirs(\"data\", exist_ok=True)  # Ensure the data directory exists\n    with open(pickle_path, \"wb\") as f:\n        pickle.dump(parameters, f)\n    print(f\"Parameters saved to {pickle_path}\")\n\n    return parameters\n\n\ndef load_or_fetch_dataset(database_id, indicator):\n    file_name = f\"{database_id}.{indicator}.csv\"\n    csv_path = os.path.join(\"data\", file_name)\n\n    # Try to load from CSV file\n    if os.path.exists(csv_path):\n        try:\n            return pd.read_csv(csv_path)\n        except Exception as e:\n            print(f\"Error loading CSV file: {e}\")\n\n    # If CSV doesn't exist or couldn't be loaded, fetch from API\n    print(f\"Fetching dataset for {database_id}.{indicator} from IMF API...\")\n    dataset = imfp.imf_dataset(database_id=database_id, indicator=[indicator])\n\n    # Save to CSV file for future use\n    os.makedirs(\"data\", exist_ok=True)  # Ensure the data directory exists\n    dataset.to_csv(csv_path, index=False)\n    print(f\"Dataset saved to {csv_path}\")\n\n    return dataset\n\n```\n\nHere is a brief introduction about the packages used:\n\n`pandas`: view and manipulate data frame\n\n`matplotlib.pyplot`: make plots\n\n`seaborn`: make plots\n\n`numpy`: computation\n\n`LinearRegression`: implement linear regression\n\n`tabulate`: format data into tables\n\n`statsmodels.api`, `adfuller`, `ARIMA`,`VAR`,`plot_acf`,`plot_pacf`,`mean_absolute_error`,`mean_squared_error`, and`grangercausalitytests` are specifically used for time series analysis. \n\n```{python}\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom tabulate import tabulate\nimport statsmodels.api as sm\nfrom statsmodels.tsa.stattools import adfuller\nfrom statsmodels.tsa.arima.model import ARIMA\nfrom statsmodels.tsa.vector_ar.var_model import VAR\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.metrics import mean_squared_error\nfrom statsmodels.tsa.stattools import grangercausalitytests\n```\n\n## Data Fetching\nIn this section, we extracted four datasets through API calls: Gender Inequality Index(GII), GDP Deflator, Nominal GDP, and Population.  \n\n```{python}\nfrom pathlib import Path\nPath(\"data\").mkdir(exist_ok=True)\n```\n\n```{python}\n# Load or fetch databases\ndatabases = load_or_fetch_databases()\n\n# Filter out databases that contain a year in the description\ndatabases[\n  ~databases['description'].str.contains(r\"[\\d]{4}\", regex=True)\n]\n\n# view_dataframe_in_browser(databases)\n```\n\nTwo databases were used: Gender Equality and International Financial Statistics (IFS).\n\n```{python}\ndatasets = [\"GENDER_EQUALITY\", \"IFS\"]\nparams = {}\n\n# Fetch valid parameters for two datasets\nfor dataset in datasets:\n    params[dataset] = load_or_fetch_parameters(dataset)\n\n    valid_keys = list(params[dataset].keys())\n    print(f\"Parameters for {dataset}: \", valid_keys)\n\n# view_dataframe_in_browser(params.get(\"IFS\").get(\"indicator\"))\n```\n\n“freq” stands for Frequency, such as Annual, Monthly, or Quarterly. \"ref_area\" stands for Geogrpahical Area, such as US (United States), JP (Japan), and GB (United Kindom). “indicator\" refers to the specific dataset in the database, including input code and description. For example, if we display all the indicators for IFS database, the GDP deflator dataset has an input code of \"NGDP_D_SA_IX\" with a full name description of Gross Domestic Product, Deflator, Seasonally Adjusted, Index. \n\nWe paired the database with the specific dataset indicator to read and store the csv file. \n\n```{python}\ndatasets = {}\ndsets = [(\"GENDER_EQUALITY\", \"GE_GII\"), (\"IFS\", \"NGDP_D_SA_IX\"), (\"IFS\", \"NGDP_XDC\"), (\"IFS\", \"LP_PE_NUM\")]\n\nfor dset in dsets:\n    datasets[dset[0] + \".\" + dset[1]] = load_or_fetch_dataset(dset[0], dset[1])\n```\n\n\n```{python}\n# \"Gender Inequality Index\"\nGII = \"GENDER_EQUALITY.GE_GII\"\n\n# \"Gross Domestic Product, Deflator, Seasonally Adjusted, Index\"\nGDP_deflator = \"IFS.NGDP_D_SA_IX\"\n\n# \"Gross Domestic Product, Nominal, Domestic Currency\"\nGDP_nominal = \"IFS.NGDP_XDC\"\n\n# \"Population, Persons, Number of\"\nGDP_population = \"IFS.LP_PE_NUM\"\n\n# Assign the datasets to new variables so we don't change the originals\nGII_data = datasets[GII]\nGDP_deflator_data = datasets[GDP_deflator]\nGDP_nominal_data = datasets[GDP_nominal]\nGDP_population_data = datasets[GDP_population]\n```\n\n## Feature Engineering\n### Data Cleaning\nSince the GDP deflator was reported on a quarterly basis, we converted it to a yearly basis.\n```{python}\n# Filter to keep only rows with a partial string match for \"Q4\" in the time_period column\nGDP_deflator_data = GDP_deflator_data[GDP_deflator_data['time_period'].str.contains(\"Q4\")]\n\n```\n\n```{python}\n# Split the time_period into year and quarter and keep the year only\nGDP_deflator_data.loc[:, 'time_period'] = GDP_deflator_data['time_period'].str[0:4]\n```\n\nWe made all the variables numeric.\n```{python}\ndatasets = [GII_data, GDP_deflator_data, GDP_nominal_data, GDP_population_data]\n\nfor i, dataset in enumerate(datasets):    \n    # Use .loc to modify the columns\n    datasets[i].loc[:, 'obs_value'] = pd.to_numeric(datasets[i]['obs_value'], errors='coerce')\n    datasets[i].loc[:, 'time_period'] = pd.to_numeric(datasets[i]['time_period'], errors='coerce')\n    datasets[i].loc[:, 'unit_mult'] = pd.to_numeric(datasets[i]['unit_mult'], errors='coerce')\n```\n\n### GII Percent Change: Dependent Variable\nWe kept percents as decimals to make them easy to work with for calculation. Different countries have different baseline level of economic growth and gender equality. We calculated the percent change to make them comparable. \n\n```{python}\n# Calculate percent change for each ref_area\nGII_data[f'pct_change'] = GII_data.sort_values(['ref_area', 'time_period']).groupby('ref_area')['obs_value'].pct_change()\n\n# Display the first few rows of the updated dataset\nGII_data.head()\n```\n\nWe subset the data frame to keep only the columns we want:\n```{python}\n# Create a new dataframe with only the required columns\nGII_data = GII_data[['ref_area', 'time_period', 'pct_change']].copy()\n\n# Display the first few rows of the new dataset\nGII_data.head()\n```\n\n\n### GDP: Independent Variable\nWe kept the columns we want only for GDP-related datasets for easier table merging.\n\n```{python}\n# GDP Deflator Dataset\n# Create a new dataframe with only the required columns\nGDP_deflator_data = GDP_deflator_data[['ref_area', 'time_period', 'unit_mult', 'obs_value']].copy()\n\n# Divide obs_value by 100\nGDP_deflator_data['obs_value'] = GDP_deflator_data['obs_value'] / 100\n\n# Display the first few rows of the new dataset\nGDP_deflator_data.head()\n```\n\n```{python}\n# GDP Nominal Data\n# Create a new dataframe with only the required columns\nGDP_nominal_data = GDP_nominal_data[['ref_area', 'time_period', 'unit_mult','obs_value']].copy()\n\n# Display the first few rows of the new dataset\nGDP_nominal_data.head()\n```\n\n```{python}\n# GDP Population Data \n# Create a new dataframe with only the required columns\nGDP_population_data = GDP_population_data[['ref_area', 'time_period', 'unit_mult','obs_value']].copy()\n\n# Display the first few rows of the new dataset\nGDP_population_data.head()\n```\n\n\n```{python}\n# Combine all the datasets above for further calculation\nmerged_df = pd.merge(pd.merge(GDP_deflator_data,GDP_nominal_data, on=['time_period', 'ref_area'], suffixes=('_index', '_nominal'), how='inner'), GDP_population_data, on=['time_period', 'ref_area'], how='inner')\n\n# Display the GDP data in a web browser\n# view_dataframe_in_browser(merged_df)\n\n# Display the first few rows of the dataset\nmerged_df.head()\n```\n\nWe want to adjust GDP data based on unit multiplier. Unit multiplier stands for the number of zeroes we need to add to the value column. For example, in 1950, the observed population data for country GA (Georgia) was 473.296. With a unit muliplier of 3, the adjusted population would be 473296.\n\n```{python}\nmerged_df['adjusted_index'] = merged_df['obs_value_index'] * (10 ** (merged_df['unit_mult_index']))\nmerged_df['adjusted_nominal'] = merged_df['obs_value_nominal'] * (10 ** (merged_df['unit_mult_nominal']))\nmerged_df['adjusted_population'] = merged_df['obs_value'] * (10 ** (merged_df['unit_mult']))\n```\n\n\n```{python}\n# Merged dataset\n# Create a new dataframe with only the required columns\nmerged_df = merged_df[['ref_area', 'time_period','adjusted_nominal', 'adjusted_index', 'adjusted_population']].copy()\n\n# Display the first few rows of the dataset\nmerged_df.head()\n```\n\nWe wanted to compute the Real GDP per capita.\n```{python}\n# Step 1: Real GDP = (Nominal GDP / GDP Deflator Index)\nmerged_df['Real_GDP_domestic'] = (merged_df['adjusted_nominal'] / merged_df['adjusted_index'])\n\n# Step 2: Real GDP per Capita = Real GDP / Population\nmerged_df['Real_GDP_per_capita'] = merged_df['Real_GDP_domestic'] / merged_df['adjusted_population']\n\n# Check the results\nmerged_df.head()\n```\n\nWe calculated the percentage change in Real GDP per capita and put it in a new column.\n\n```{python}\n# Calculate percent change for each ref_area\nmerged_df[f'GDP_change'] = merged_df.sort_values(['ref_area', 'time_period']).groupby('ref_area')['Real_GDP_per_capita'].pct_change()\n\n# Rename dataset\nGDP_data = merged_df\n\n# Display the first few rows of the dataset\nGDP_data.head()\n```\n\n\n```{python}\n# GII and GDP\n# Merge the datasets\ncombined_data = pd.merge(GII_data, GDP_data, on=[\"ref_area\", \"time_period\"], how = \"inner\")\n\n# Check the combined dataset\ncombined_data.head()\n```\n\n\n```{python}\n# GII and GDP\n# Rename columns\ncombined_data = combined_data.rename(columns = {\n    \"ref_area\": \"Country\",\n    \"time_period\": \"Time\",\n    \"pct_change\": \"GII_change\"\n})\n\n# Display the GDP data in a web browser\n# view_dataframe_in_browser(combined_data)\n\n# Check the combined dataset\ncombined_data.head()\n```\n\n## Data Visualization\n### Scatterplot\nScatterplot use dots to represent values of two numeric variables. The horizontal axis was the percent change in Real GDP per capita. The vertical axis was the percent change in Gender Inequality Index(GII). Different colors represented different countries. We used a linear regression line to display the overall pattern. \n\nBased on the scatterplot, it seemed like there was a slight positive relationship between GDP change and GII change as shown by the flat regression line. Gender inequality was decreasing (gender equality was improving) a little faster in country-years with low GDP growth and a little slower in country-years with high GDP growth.\n\n```{python}\n# Drop NAs\ncombined_data = combined_data.dropna(subset=['GDP_change', 'GII_change'])\n\n# Plot the data points\nplt.figure(figsize=(18, 10))\nfor country in combined_data['Country'].unique():\n    country_data = combined_data[combined_data['Country'] == country]\n    plt.scatter(country_data['GDP_change'], country_data['GII_change'],\n             marker='o',linestyle='-', label=country)\nplt.title('Country-Year Analysis of GDP Change vs. GII Change')\nplt.xlabel('Percent Change in Real GDP per Capita (Country-Year)')\nplt.ylabel('Percent Change in GII (Country-Year)')\nplt.grid(True)\n\n# Prepare data for linear regression\nX = combined_data['GDP_change'].values.reshape(-1, 1)\ny = combined_data['GII_change'].values\n\n# Perform linear regression\nreg = LinearRegression().fit(X, y)\ny_pred = reg.predict(X)\n\n# Plot the regression line\nplt.plot(combined_data['GDP_change'], y_pred, color='red', linewidth=2)\n\nplt.show()\n\n```\n\n### Time Series Line Plot\nWe created separate line plots for GDP change and GII change over time for a few key countries might show the trends more clearly. \n\nUS: United States\n\nJP: Japan\n\nGB: United Kindom\n\nFR: France\n\nMX: Mexico\n\nBased on the line plots, we saw GDP change and GII change have different patterns. For example, in Mexico, when there was a big change in real GDP per captia in 1995, the change in GII was pretty stable. \n```{python}\n# Time Series Line plot for a few key countries\nselected_countries  = ['US', 'JP', 'GB', 'FR', 'MX']\ncombined_data_selected = combined_data[combined_data['Country'].isin(selected_countries)]\n\n# Set up the Plot Structure\nfig, ax = plt.subplots(2, 1, figsize=(18, 10), sharex=True)\n\n# Plot change in real GDP per capita over time\nsns.lineplot(data = combined_data_selected, x = \"Time\", y = \"GDP_change\", hue = \"Country\", ax = ax[0])\nax[0].set_title(\"Percent Change in Real GDP per Capita Over Time\")\nax[0].set_ylabel(\"Percent Change in Real GDP per Capita\")\n\n# Plot change in GII over time\nsns.lineplot(data = combined_data_selected, x = \"Time\", y = \"GII_change\", hue = \"Country\", ax = ax[1])\nax[1].set_title(\"Percent Change in GII over Time\")\nax[1].set_xlabel(\"Time\")\nax[1].set_ylabel(\"GII\")\n\nplt.tight_layout\nplt.show()\n```\n\n### Barplot\nWe used a barplot to show average changes in GII and GDP percent change for each country to visualize regions where inequality was improving or worsening. \n\nThis plot supported our previous observation how GII change seemed to be not be correlated with GDP change. We also saw that, for country SI, Solvenia, there seems to be a large improvement in gender inequality.  \n\n```{python}\n# Barplot using average GII and GDP change\n# Calculate average change for each country\ncombined_data_avg = combined_data.groupby('Country')[['GII_change','GDP_change']].mean().reset_index()\n\n# Prepare to plot structure \nplt.figure(figsize = (18,10))\n\n# Create the barplot\ncombined_data_avg.plot(kind = 'bar', x = 'Country')\nplt.ylabel('Average Change')\nplt.xlabel('Country')\nplt.legend(['GII change', 'GDP change'])\nplt.grid(axis = 'y')\n\n# Show the plot\nplt.show()\n```\n\n### Boxplot\nWe used boxplot to visualize the distribution of GDP and GII change by country, providing information about spread, median, and potential outliers. To provide a more informative view, we sequenced countries in an ascending order by the median of percent change in GDP.\n\nThe boxplot displayed a slight upward trend with no obvious pattern between GDP and GII change. In coutries with higher GDP change median, they also tend to have a larger spread of the GDP change. The median of GII change remained stable regardless of the magnitude of GDP change, implying weak or no association between GDP and GII change. We observed a potential outlier for country SI, Solvenia, which may explained its large improvement in Gender inequality. \n\n```{python}\n# Box plot for GII and GDP change\n# Melt the dataframe to long format for combined boxplot\ncombined_data_melted = combined_data.melt(id_vars=['Country'], value_vars=['GII_change', 'GDP_change'], \n                                          var_name='Change_Type', value_name='Value')\n\ngdp_medians = combined_data.groupby('Country')['GDP_change'].median().sort_values()\n\ncombined_data_melted['Country'] = pd.Categorical(combined_data_melted['Country'], categories=gdp_medians.index, ordered= True)\n\n# Prepare the plot structure\nplt.figure(figsize=(18, 10))\nsns.boxplot(data = combined_data_melted, x = \"Country\", y = 'Value', hue = 'Change_Type')\nplt.title('Distribution of GII and GDP change by Country')\nplt.xlabel('Country')\nplt.ylabel('Change')\nplt.legend(title = 'Change Type')\n\n# Show the plot\nplt.show()\n```\n\n### Correlation Matrix\nWe created a heatmap to show the relationship between GII and GDP change.\n\nA positive correlation coefficient indicates a positive relationship: the larger the GDP change, the larger the GII change. A negative correlation coefficient indicates a negative relationship: the larger the GDP change, the smaller the GII change. A correlation coefficient closer to 0 indicates there is weak or no relationship. \n\nBased on the numeric values in the plot, there was a moderately strong positive correlation between GII and GDP change for country Estonia(EE) and Ireland(IE). \n\n```{python}\n# Calculate the correlation\ncountry_correlation = combined_data.groupby('Country')[['GII_change', 'GDP_change']].corr().iloc[0::2, -1].reset_index(name='Correlation')\n\n# Put the correlation value in a matrix format\ncorrelation_matrix = country_correlation.pivot(index='Country', columns='level_1', values='Correlation')\n\n# Check for NaN values in the correlation matrix\ncorrelation_matrix.fillna(0, inplace=True)  # Replace NaNs with 0 or another value as appropriate\n\n# Set up the plot structure\nplt.figure(figsize=(18, 12))  # Adjust height to give more space for y-axis labels\n\n# Plot the heatmap\nsns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0, cbar_kws={\"shrink\": .8}, linewidths=.5)\n\n# Enhance axis labels and title\nplt.title('Heatmap for GII and GDP Change', fontsize=20)\nplt.xlabel('Variables', fontsize=16)\nplt.ylabel('Country', fontsize=16)\n\n# Improve readability of y-axis labels\nplt.yticks(fontsize=12)  # Adjust the font size for y-axis labels\n\n# Show the plot\nplt.show()\n```\n\n## Statistical Analysis \n### Descriptive Statistics\nThere was a total of 915 data points. The mean of the GII change in -0.0314868, which indicated the overall grand mean percent change in gender inequality index is -3.15%. The mean of the GDP change was 0.0234633, showing the overall grand mean percent change in real GDP per capita was 2.35%. \n```{python}\n# Generate summary statistics\ndescriptive_stats = combined_data.describe()\nprint(tabulate(descriptive_stats, headers='keys', tablefmt='github'))\n```\n\n### Regression Analysis\nSimple linear regression as a foundational approach provide us with a basic understanding of the relationship between GDP change and GII change. \n\nBased on the summary, we concluded the following:\n\n* Becasue p-value = 0.057, if we set alpha, the significance level, to be 0.05, we failed to reject the null hypothesis and conclude there was no significant relationship between percent change in real GDP per capita and gender inequality index. \n\n* R-squared = 0.004. Only 0.4% of the variance in GII change could be explained by GDP change.\n\n* We were 95% confident that the interval from -0.003 to 0.169 captured the true slope of GDP change. Because 0 was included, we are uncertain about the effect of GDP change on GII chnage.\n\n```{python}\n# Define independent and depenent variables\nX = combined_data['GDP_change']\ny = combined_data['GII_change']\n\n# Add a constant to indepdent variable to include an intercept\nX = sm.add_constant(X)\n\n# Fit a simple linear regresion model and print out the summary\nmodel = sm.OLS(y, X).fit()\nprint(model.summary())\n```\n\n### Time Series Analysis\nTime series analysis allows us to explore how the relationship between GII and GDP change vary across different time periods, accounting for lagged effects. \n\nHere was a quick summary of the result:\n* Both GII and GDP change time series were stationary.\n\n* Past GII change values significantly influenced cuurent GII change values.\n\n* VAR model had good model performance on forecasting future values based on historical data. \n\n* Changes in GDP did not cause/precde the changes in GII. \n\n#### ADF Test: Stationality Assumption Check\nWe wanted to use Augmented Dickey-Fuller (ADF) test to check whether a time series was stationary, which was the model assumption for many time series models. \n\nStationarity implied constant mean and variance over time, making it more predictable and stable for forecasting. \n\nBased on the ADF test output, both GII and GDP change time series were stationary. We proceeded to the time series modeling section. \n```{python}\n# Augmented Dickey-Fuller (ADF) test for stationarity check\n# Create melted datasets\ncombined_data_time = combined_data.melt(id_vars=['Time', 'Country'], value_vars=['GII_change','GDP_change'], var_name = 'Change_Type', value_name = 'Value')\nGII = combined_data_time[(combined_data_time['Change_Type'] == 'GII_change')]                         \n\nGDP = combined_data_time[(combined_data_time['Change_Type'] == 'GDP_change')]\n\n# Stationary Check\ndef adf_test(series):\n    result = adfuller(series.dropna())\n    print(f'ADF Statistic: {result[0]}')\n    print(f'p-value: {result[1]}')\n    if result[1] < 0.05:\n        print(\"Series is stationary\")\n    else:\n        print(\"Series is not stationary\")\n\n# Output the result\nadf_test(GII['Value'])\nadf_test(GDP['Value'])\n```\n\n#### VAR model: Examine variables separately\nWe fitted a VAR (Vector Autoreression) model to see the relationship between GII and GDP change. VAR is particularly useful when dealing with multivariate time series data and allows us to examine the interdependence between variables. \n\nBased on summary, here were several interpretations we could make:\n\n* We used AIC as the criteria for model selection. Lower value suggests a better fit. \n\n* Given that we wanted to predict GII change, we focused on the first set \"Results for equation GII_change.\"\n\n* Past GII_change values significantly influenced current GII_change, as shown in the small p-values of lags 1 and 2. \n\n* Lag 2 of GDP_change had a relatively low p-value but is not statistically significant.\n\n```{python}\n# Split the dataset into training and testing sets\nsplit_ratio = 0.7\nsplit_index = int(len(combined_data) * split_ratio)\n\n# Training set is used to fit the model\ntrain_data = combined_data.iloc[:split_index]\n\n# Testing set is used for validation\ntest_data = combined_data.iloc[split_index:]\n\nprint(f\"Training data: {train_data.shape}\")\nprint(f\"Test data: {test_data.shape}\")\n```\n\n```{python}\n# Fit a VAR model \ntime_model = VAR(train_data[['GII_change', 'GDP_change']])\ntime_model_fitted = time_model.fit(maxlags = 15, ic=\"aic\")\n\n# Print out the model summary\nprint(time_model_fitted.summary())\n```\n\n#### VAR Model: Forecasting\nWe applied the model learned above to the test data. Based on the plot, the forecast values seem to follow the actual data well, indicating a good model fit caputuring the underlying trends.\n```{python}\n# Number of steps to forecast (length of the test set)\nn_steps = len(test_data)\n\n# Get the last values from the training set for forecasting\nforecast_input = train_data[['GII_change', 'GDP_change']].values[-time_model_fitted.k_ar:]\n\n# Forecasting\nforecast = time_model_fitted.forecast(y=forecast_input, steps=n_steps)\n\n# Create a DataFrame for the forecasted values\nforecast_df = pd.DataFrame(forecast, index=test_data.index, columns=['GII_forecast', 'GDP_forecast'])\n\n# Ensure the index of the forecast_df matches the test_data index\nforecast_df.index = test_data.index\n```\n\n```{python}\nplt.figure(figsize=(12, 6))\nplt.plot(train_data['GII_change'], label='Training GII', color='blue')\nplt.plot(test_data['GII_change'], label='Actual GII', color='orange')\nplt.plot(forecast_df['GII_forecast'], label='Forecasted GII', color='green')\nplt.title('GII Change Forecast vs Actual')\nplt.legend()\nplt.show()\n\nplt.figure(figsize=(12, 6))\nplt.plot(train_data['GDP_change'], label='Training GDP', color='blue')\nplt.plot(test_data['GDP_change'], label='Actual GDP', color='orange')\nplt.plot(forecast_df['GDP_forecast'], label='Forecasted GDP', color='green')\nplt.title('GDP Change Forecast vs Actual')\nplt.legend()\nplt.show()\n```\n\n#### VAR Model: Model Performance\nLow values of both MAE and RMSE indicate good model performance with small average errors in predictions. \n```{python}\nmae_gii = mean_absolute_error(test_data['GII_change'], forecast_df['GII_forecast'])\nmae_gdp = mean_absolute_error(test_data['GDP_change'], forecast_df['GDP_forecast'])\n\nprint(f'Mean Absolute Error for GII: {mae_gii}')\nprint(f'Mean Absolute Error for GDP: {mae_gdp}')\n```\n\n\n```{python}\nrmse_gii = np.sqrt(mean_squared_error(test_data['GII_change'], forecast_df['GII_forecast']))\nrmse_gdp = np.sqrt(mean_squared_error(test_data['GDP_change'], forecast_df['GDP_forecast']))\n\nprint(f'RMSE for GII: {rmse_gii}')\nprint(f'RMSE for GDP: {rmse_gdp}')\n```\n\n#### VAR Model: Granger causality test\nGranger causality test evaluates whether one time series can predict another. \n\nBased on the output, the lowest p-value is when lag = 2. However, because p-value > 0.05, we fail to reject the null hypothesis and conclude the GDP_change does not Granger-cause the GII_change.\n```{python}\n# Perform the Granger causality test\nmax_lag = 3\ntest_result = grangercausalitytests(train_data[['GII_change', 'GDP_change']], max_lag, verbose=True)\n\n```\n\n## Conclusion\nIn wrapping up our analysis, we found no evidence to support a significant relationship between the Change in Real GDP per capita and the Change in the Gender Inequality Index (GII). This suggests that economic growth may not have a direct impact on gender equality. However, our findings open the door to questions for future research. Check out the blog for full analysis!\n\n\n","srcMarkdownNoYaml":"\n\nThis data analysis project aims to explore the relationship between economic growth and gender equality using `imfp`, which allows us to download data from IMF (International Monetary Fund). `imfp` can be integrated with other python tools to streamline the computational process. To demonstrate its functionality, the project experimented with a variety of visualization and analysis methods. \n\n## Executive Summary\n\nIn this project, we explored the following:\n\n1. **Data Fetching**\n* Make API call to fetch 4 datasets: GII (Gender Inequality Index), Nominal GDP, GDP Deflator Index, Population series\n\n2. **Feature Engineering**\n* Cleaning: Convert GDP Deflator Index to a yearly basis and variables to numeric\n* Dependent Variable: Percent Change of Gender Inequality Index\n* Independent Variable: Percent Change of Real GDP per Capita \n* Transform variables to display magnitude of change \n* Merge the datasets\n\n3. **Data Visualization**\n* Scatterplot\n* Time Series Line Plots\n* Barplot\n* Boxplot\n* Heatmap\n\n4. **Statistical Analysis**\n* Descriptive Statistics\n* Regression Analysis\n* Time Series Analysis\n\n## Suggested packages\nThe integration of other Python tools not only streamlined our computational processes but also ensured consistency across the project.\n\nA custom module is written to simplify the process of making API calls and fetching information with imfp library. `load_or_fetch_databases`, `load_or_fetch_parameters` `load_or_fetch_dataset` load and retreive database, parameters, and dataset from a local or remote source. `view_dataframe_in_browser` displays dataframe in a web browser.\n\n```{python}\nimport os\nimport pickle\nfrom tempfile import NamedTemporaryFile\nimport pandas as pd\nimport imfp\nimport webbrowser\n\n\n# Function to display a DataFrame in a web browser\ndef view_dataframe_in_browser(df):\n    html = df.to_html()\n    with NamedTemporaryFile(delete=False, mode=\"w\", suffix=\".html\") as f:\n        url = \"file://\" + f.name\n        f.write(html)\n    webbrowser.open(url)\n\n\n# Function to load databases from CSV or fetch from API\ndef load_or_fetch_databases():\n    csv_path = os.path.join(\"data\", \"databases.csv\")\n\n    # Try to load from CSV\n    if os.path.exists(csv_path):\n        try:\n            return pd.read_csv(csv_path)\n        except Exception as e:\n            print(f\"Error loading CSV: {e}\")\n\n    # If CSV doesn't exist or couldn't be loaded, fetch from API\n    print(\"Fetching databases from IMF API...\")\n    databases = imfp.imf_databases()\n\n    # Save to CSV for future use\n    databases.to_csv(csv_path, index=False)\n    print(f\"Databases saved to {csv_path}\")\n\n    return databases\n\n\ndef load_or_fetch_parameters(database_name):\n    pickle_path = os.path.join(\"data\", f\"{database_name}.pickle\")\n\n    # Try to load from pickle file\n    if os.path.exists(pickle_path):\n        try:\n            with open(pickle_path, \"rb\") as f:\n                return pickle.load(f)\n        except Exception as e:\n            print(f\"Error loading pickle file: {e}\")\n\n    # If pickle doesn't exist or couldn't be loaded, fetch from API\n    print(f\"Fetching parameters for {database_name} from IMF API...\")\n    parameters = imfp.imf_parameters(database_name)\n\n    # Save to pickle file for future use\n    os.makedirs(\"data\", exist_ok=True)  # Ensure the data directory exists\n    with open(pickle_path, \"wb\") as f:\n        pickle.dump(parameters, f)\n    print(f\"Parameters saved to {pickle_path}\")\n\n    return parameters\n\n\ndef load_or_fetch_dataset(database_id, indicator):\n    file_name = f\"{database_id}.{indicator}.csv\"\n    csv_path = os.path.join(\"data\", file_name)\n\n    # Try to load from CSV file\n    if os.path.exists(csv_path):\n        try:\n            return pd.read_csv(csv_path)\n        except Exception as e:\n            print(f\"Error loading CSV file: {e}\")\n\n    # If CSV doesn't exist or couldn't be loaded, fetch from API\n    print(f\"Fetching dataset for {database_id}.{indicator} from IMF API...\")\n    dataset = imfp.imf_dataset(database_id=database_id, indicator=[indicator])\n\n    # Save to CSV file for future use\n    os.makedirs(\"data\", exist_ok=True)  # Ensure the data directory exists\n    dataset.to_csv(csv_path, index=False)\n    print(f\"Dataset saved to {csv_path}\")\n\n    return dataset\n\n```\n\nHere is a brief introduction about the packages used:\n\n`pandas`: view and manipulate data frame\n\n`matplotlib.pyplot`: make plots\n\n`seaborn`: make plots\n\n`numpy`: computation\n\n`LinearRegression`: implement linear regression\n\n`tabulate`: format data into tables\n\n`statsmodels.api`, `adfuller`, `ARIMA`,`VAR`,`plot_acf`,`plot_pacf`,`mean_absolute_error`,`mean_squared_error`, and`grangercausalitytests` are specifically used for time series analysis. \n\n```{python}\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom tabulate import tabulate\nimport statsmodels.api as sm\nfrom statsmodels.tsa.stattools import adfuller\nfrom statsmodels.tsa.arima.model import ARIMA\nfrom statsmodels.tsa.vector_ar.var_model import VAR\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.metrics import mean_squared_error\nfrom statsmodels.tsa.stattools import grangercausalitytests\n```\n\n## Data Fetching\nIn this section, we extracted four datasets through API calls: Gender Inequality Index(GII), GDP Deflator, Nominal GDP, and Population.  \n\n```{python}\nfrom pathlib import Path\nPath(\"data\").mkdir(exist_ok=True)\n```\n\n```{python}\n# Load or fetch databases\ndatabases = load_or_fetch_databases()\n\n# Filter out databases that contain a year in the description\ndatabases[\n  ~databases['description'].str.contains(r\"[\\d]{4}\", regex=True)\n]\n\n# view_dataframe_in_browser(databases)\n```\n\nTwo databases were used: Gender Equality and International Financial Statistics (IFS).\n\n```{python}\ndatasets = [\"GENDER_EQUALITY\", \"IFS\"]\nparams = {}\n\n# Fetch valid parameters for two datasets\nfor dataset in datasets:\n    params[dataset] = load_or_fetch_parameters(dataset)\n\n    valid_keys = list(params[dataset].keys())\n    print(f\"Parameters for {dataset}: \", valid_keys)\n\n# view_dataframe_in_browser(params.get(\"IFS\").get(\"indicator\"))\n```\n\n“freq” stands for Frequency, such as Annual, Monthly, or Quarterly. \"ref_area\" stands for Geogrpahical Area, such as US (United States), JP (Japan), and GB (United Kindom). “indicator\" refers to the specific dataset in the database, including input code and description. For example, if we display all the indicators for IFS database, the GDP deflator dataset has an input code of \"NGDP_D_SA_IX\" with a full name description of Gross Domestic Product, Deflator, Seasonally Adjusted, Index. \n\nWe paired the database with the specific dataset indicator to read and store the csv file. \n\n```{python}\ndatasets = {}\ndsets = [(\"GENDER_EQUALITY\", \"GE_GII\"), (\"IFS\", \"NGDP_D_SA_IX\"), (\"IFS\", \"NGDP_XDC\"), (\"IFS\", \"LP_PE_NUM\")]\n\nfor dset in dsets:\n    datasets[dset[0] + \".\" + dset[1]] = load_or_fetch_dataset(dset[0], dset[1])\n```\n\n\n```{python}\n# \"Gender Inequality Index\"\nGII = \"GENDER_EQUALITY.GE_GII\"\n\n# \"Gross Domestic Product, Deflator, Seasonally Adjusted, Index\"\nGDP_deflator = \"IFS.NGDP_D_SA_IX\"\n\n# \"Gross Domestic Product, Nominal, Domestic Currency\"\nGDP_nominal = \"IFS.NGDP_XDC\"\n\n# \"Population, Persons, Number of\"\nGDP_population = \"IFS.LP_PE_NUM\"\n\n# Assign the datasets to new variables so we don't change the originals\nGII_data = datasets[GII]\nGDP_deflator_data = datasets[GDP_deflator]\nGDP_nominal_data = datasets[GDP_nominal]\nGDP_population_data = datasets[GDP_population]\n```\n\n## Feature Engineering\n### Data Cleaning\nSince the GDP deflator was reported on a quarterly basis, we converted it to a yearly basis.\n```{python}\n# Filter to keep only rows with a partial string match for \"Q4\" in the time_period column\nGDP_deflator_data = GDP_deflator_data[GDP_deflator_data['time_period'].str.contains(\"Q4\")]\n\n```\n\n```{python}\n# Split the time_period into year and quarter and keep the year only\nGDP_deflator_data.loc[:, 'time_period'] = GDP_deflator_data['time_period'].str[0:4]\n```\n\nWe made all the variables numeric.\n```{python}\ndatasets = [GII_data, GDP_deflator_data, GDP_nominal_data, GDP_population_data]\n\nfor i, dataset in enumerate(datasets):    \n    # Use .loc to modify the columns\n    datasets[i].loc[:, 'obs_value'] = pd.to_numeric(datasets[i]['obs_value'], errors='coerce')\n    datasets[i].loc[:, 'time_period'] = pd.to_numeric(datasets[i]['time_period'], errors='coerce')\n    datasets[i].loc[:, 'unit_mult'] = pd.to_numeric(datasets[i]['unit_mult'], errors='coerce')\n```\n\n### GII Percent Change: Dependent Variable\nWe kept percents as decimals to make them easy to work with for calculation. Different countries have different baseline level of economic growth and gender equality. We calculated the percent change to make them comparable. \n\n```{python}\n# Calculate percent change for each ref_area\nGII_data[f'pct_change'] = GII_data.sort_values(['ref_area', 'time_period']).groupby('ref_area')['obs_value'].pct_change()\n\n# Display the first few rows of the updated dataset\nGII_data.head()\n```\n\nWe subset the data frame to keep only the columns we want:\n```{python}\n# Create a new dataframe with only the required columns\nGII_data = GII_data[['ref_area', 'time_period', 'pct_change']].copy()\n\n# Display the first few rows of the new dataset\nGII_data.head()\n```\n\n\n### GDP: Independent Variable\nWe kept the columns we want only for GDP-related datasets for easier table merging.\n\n```{python}\n# GDP Deflator Dataset\n# Create a new dataframe with only the required columns\nGDP_deflator_data = GDP_deflator_data[['ref_area', 'time_period', 'unit_mult', 'obs_value']].copy()\n\n# Divide obs_value by 100\nGDP_deflator_data['obs_value'] = GDP_deflator_data['obs_value'] / 100\n\n# Display the first few rows of the new dataset\nGDP_deflator_data.head()\n```\n\n```{python}\n# GDP Nominal Data\n# Create a new dataframe with only the required columns\nGDP_nominal_data = GDP_nominal_data[['ref_area', 'time_period', 'unit_mult','obs_value']].copy()\n\n# Display the first few rows of the new dataset\nGDP_nominal_data.head()\n```\n\n```{python}\n# GDP Population Data \n# Create a new dataframe with only the required columns\nGDP_population_data = GDP_population_data[['ref_area', 'time_period', 'unit_mult','obs_value']].copy()\n\n# Display the first few rows of the new dataset\nGDP_population_data.head()\n```\n\n\n```{python}\n# Combine all the datasets above for further calculation\nmerged_df = pd.merge(pd.merge(GDP_deflator_data,GDP_nominal_data, on=['time_period', 'ref_area'], suffixes=('_index', '_nominal'), how='inner'), GDP_population_data, on=['time_period', 'ref_area'], how='inner')\n\n# Display the GDP data in a web browser\n# view_dataframe_in_browser(merged_df)\n\n# Display the first few rows of the dataset\nmerged_df.head()\n```\n\nWe want to adjust GDP data based on unit multiplier. Unit multiplier stands for the number of zeroes we need to add to the value column. For example, in 1950, the observed population data for country GA (Georgia) was 473.296. With a unit muliplier of 3, the adjusted population would be 473296.\n\n```{python}\nmerged_df['adjusted_index'] = merged_df['obs_value_index'] * (10 ** (merged_df['unit_mult_index']))\nmerged_df['adjusted_nominal'] = merged_df['obs_value_nominal'] * (10 ** (merged_df['unit_mult_nominal']))\nmerged_df['adjusted_population'] = merged_df['obs_value'] * (10 ** (merged_df['unit_mult']))\n```\n\n\n```{python}\n# Merged dataset\n# Create a new dataframe with only the required columns\nmerged_df = merged_df[['ref_area', 'time_period','adjusted_nominal', 'adjusted_index', 'adjusted_population']].copy()\n\n# Display the first few rows of the dataset\nmerged_df.head()\n```\n\nWe wanted to compute the Real GDP per capita.\n```{python}\n# Step 1: Real GDP = (Nominal GDP / GDP Deflator Index)\nmerged_df['Real_GDP_domestic'] = (merged_df['adjusted_nominal'] / merged_df['adjusted_index'])\n\n# Step 2: Real GDP per Capita = Real GDP / Population\nmerged_df['Real_GDP_per_capita'] = merged_df['Real_GDP_domestic'] / merged_df['adjusted_population']\n\n# Check the results\nmerged_df.head()\n```\n\nWe calculated the percentage change in Real GDP per capita and put it in a new column.\n\n```{python}\n# Calculate percent change for each ref_area\nmerged_df[f'GDP_change'] = merged_df.sort_values(['ref_area', 'time_period']).groupby('ref_area')['Real_GDP_per_capita'].pct_change()\n\n# Rename dataset\nGDP_data = merged_df\n\n# Display the first few rows of the dataset\nGDP_data.head()\n```\n\n\n```{python}\n# GII and GDP\n# Merge the datasets\ncombined_data = pd.merge(GII_data, GDP_data, on=[\"ref_area\", \"time_period\"], how = \"inner\")\n\n# Check the combined dataset\ncombined_data.head()\n```\n\n\n```{python}\n# GII and GDP\n# Rename columns\ncombined_data = combined_data.rename(columns = {\n    \"ref_area\": \"Country\",\n    \"time_period\": \"Time\",\n    \"pct_change\": \"GII_change\"\n})\n\n# Display the GDP data in a web browser\n# view_dataframe_in_browser(combined_data)\n\n# Check the combined dataset\ncombined_data.head()\n```\n\n## Data Visualization\n### Scatterplot\nScatterplot use dots to represent values of two numeric variables. The horizontal axis was the percent change in Real GDP per capita. The vertical axis was the percent change in Gender Inequality Index(GII). Different colors represented different countries. We used a linear regression line to display the overall pattern. \n\nBased on the scatterplot, it seemed like there was a slight positive relationship between GDP change and GII change as shown by the flat regression line. Gender inequality was decreasing (gender equality was improving) a little faster in country-years with low GDP growth and a little slower in country-years with high GDP growth.\n\n```{python}\n# Drop NAs\ncombined_data = combined_data.dropna(subset=['GDP_change', 'GII_change'])\n\n# Plot the data points\nplt.figure(figsize=(18, 10))\nfor country in combined_data['Country'].unique():\n    country_data = combined_data[combined_data['Country'] == country]\n    plt.scatter(country_data['GDP_change'], country_data['GII_change'],\n             marker='o',linestyle='-', label=country)\nplt.title('Country-Year Analysis of GDP Change vs. GII Change')\nplt.xlabel('Percent Change in Real GDP per Capita (Country-Year)')\nplt.ylabel('Percent Change in GII (Country-Year)')\nplt.grid(True)\n\n# Prepare data for linear regression\nX = combined_data['GDP_change'].values.reshape(-1, 1)\ny = combined_data['GII_change'].values\n\n# Perform linear regression\nreg = LinearRegression().fit(X, y)\ny_pred = reg.predict(X)\n\n# Plot the regression line\nplt.plot(combined_data['GDP_change'], y_pred, color='red', linewidth=2)\n\nplt.show()\n\n```\n\n### Time Series Line Plot\nWe created separate line plots for GDP change and GII change over time for a few key countries might show the trends more clearly. \n\nUS: United States\n\nJP: Japan\n\nGB: United Kindom\n\nFR: France\n\nMX: Mexico\n\nBased on the line plots, we saw GDP change and GII change have different patterns. For example, in Mexico, when there was a big change in real GDP per captia in 1995, the change in GII was pretty stable. \n```{python}\n# Time Series Line plot for a few key countries\nselected_countries  = ['US', 'JP', 'GB', 'FR', 'MX']\ncombined_data_selected = combined_data[combined_data['Country'].isin(selected_countries)]\n\n# Set up the Plot Structure\nfig, ax = plt.subplots(2, 1, figsize=(18, 10), sharex=True)\n\n# Plot change in real GDP per capita over time\nsns.lineplot(data = combined_data_selected, x = \"Time\", y = \"GDP_change\", hue = \"Country\", ax = ax[0])\nax[0].set_title(\"Percent Change in Real GDP per Capita Over Time\")\nax[0].set_ylabel(\"Percent Change in Real GDP per Capita\")\n\n# Plot change in GII over time\nsns.lineplot(data = combined_data_selected, x = \"Time\", y = \"GII_change\", hue = \"Country\", ax = ax[1])\nax[1].set_title(\"Percent Change in GII over Time\")\nax[1].set_xlabel(\"Time\")\nax[1].set_ylabel(\"GII\")\n\nplt.tight_layout\nplt.show()\n```\n\n### Barplot\nWe used a barplot to show average changes in GII and GDP percent change for each country to visualize regions where inequality was improving or worsening. \n\nThis plot supported our previous observation how GII change seemed to be not be correlated with GDP change. We also saw that, for country SI, Solvenia, there seems to be a large improvement in gender inequality.  \n\n```{python}\n# Barplot using average GII and GDP change\n# Calculate average change for each country\ncombined_data_avg = combined_data.groupby('Country')[['GII_change','GDP_change']].mean().reset_index()\n\n# Prepare to plot structure \nplt.figure(figsize = (18,10))\n\n# Create the barplot\ncombined_data_avg.plot(kind = 'bar', x = 'Country')\nplt.ylabel('Average Change')\nplt.xlabel('Country')\nplt.legend(['GII change', 'GDP change'])\nplt.grid(axis = 'y')\n\n# Show the plot\nplt.show()\n```\n\n### Boxplot\nWe used boxplot to visualize the distribution of GDP and GII change by country, providing information about spread, median, and potential outliers. To provide a more informative view, we sequenced countries in an ascending order by the median of percent change in GDP.\n\nThe boxplot displayed a slight upward trend with no obvious pattern between GDP and GII change. In coutries with higher GDP change median, they also tend to have a larger spread of the GDP change. The median of GII change remained stable regardless of the magnitude of GDP change, implying weak or no association between GDP and GII change. We observed a potential outlier for country SI, Solvenia, which may explained its large improvement in Gender inequality. \n\n```{python}\n# Box plot for GII and GDP change\n# Melt the dataframe to long format for combined boxplot\ncombined_data_melted = combined_data.melt(id_vars=['Country'], value_vars=['GII_change', 'GDP_change'], \n                                          var_name='Change_Type', value_name='Value')\n\ngdp_medians = combined_data.groupby('Country')['GDP_change'].median().sort_values()\n\ncombined_data_melted['Country'] = pd.Categorical(combined_data_melted['Country'], categories=gdp_medians.index, ordered= True)\n\n# Prepare the plot structure\nplt.figure(figsize=(18, 10))\nsns.boxplot(data = combined_data_melted, x = \"Country\", y = 'Value', hue = 'Change_Type')\nplt.title('Distribution of GII and GDP change by Country')\nplt.xlabel('Country')\nplt.ylabel('Change')\nplt.legend(title = 'Change Type')\n\n# Show the plot\nplt.show()\n```\n\n### Correlation Matrix\nWe created a heatmap to show the relationship between GII and GDP change.\n\nA positive correlation coefficient indicates a positive relationship: the larger the GDP change, the larger the GII change. A negative correlation coefficient indicates a negative relationship: the larger the GDP change, the smaller the GII change. A correlation coefficient closer to 0 indicates there is weak or no relationship. \n\nBased on the numeric values in the plot, there was a moderately strong positive correlation between GII and GDP change for country Estonia(EE) and Ireland(IE). \n\n```{python}\n# Calculate the correlation\ncountry_correlation = combined_data.groupby('Country')[['GII_change', 'GDP_change']].corr().iloc[0::2, -1].reset_index(name='Correlation')\n\n# Put the correlation value in a matrix format\ncorrelation_matrix = country_correlation.pivot(index='Country', columns='level_1', values='Correlation')\n\n# Check for NaN values in the correlation matrix\ncorrelation_matrix.fillna(0, inplace=True)  # Replace NaNs with 0 or another value as appropriate\n\n# Set up the plot structure\nplt.figure(figsize=(18, 12))  # Adjust height to give more space for y-axis labels\n\n# Plot the heatmap\nsns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0, cbar_kws={\"shrink\": .8}, linewidths=.5)\n\n# Enhance axis labels and title\nplt.title('Heatmap for GII and GDP Change', fontsize=20)\nplt.xlabel('Variables', fontsize=16)\nplt.ylabel('Country', fontsize=16)\n\n# Improve readability of y-axis labels\nplt.yticks(fontsize=12)  # Adjust the font size for y-axis labels\n\n# Show the plot\nplt.show()\n```\n\n## Statistical Analysis \n### Descriptive Statistics\nThere was a total of 915 data points. The mean of the GII change in -0.0314868, which indicated the overall grand mean percent change in gender inequality index is -3.15%. The mean of the GDP change was 0.0234633, showing the overall grand mean percent change in real GDP per capita was 2.35%. \n```{python}\n# Generate summary statistics\ndescriptive_stats = combined_data.describe()\nprint(tabulate(descriptive_stats, headers='keys', tablefmt='github'))\n```\n\n### Regression Analysis\nSimple linear regression as a foundational approach provide us with a basic understanding of the relationship between GDP change and GII change. \n\nBased on the summary, we concluded the following:\n\n* Becasue p-value = 0.057, if we set alpha, the significance level, to be 0.05, we failed to reject the null hypothesis and conclude there was no significant relationship between percent change in real GDP per capita and gender inequality index. \n\n* R-squared = 0.004. Only 0.4% of the variance in GII change could be explained by GDP change.\n\n* We were 95% confident that the interval from -0.003 to 0.169 captured the true slope of GDP change. Because 0 was included, we are uncertain about the effect of GDP change on GII chnage.\n\n```{python}\n# Define independent and depenent variables\nX = combined_data['GDP_change']\ny = combined_data['GII_change']\n\n# Add a constant to indepdent variable to include an intercept\nX = sm.add_constant(X)\n\n# Fit a simple linear regresion model and print out the summary\nmodel = sm.OLS(y, X).fit()\nprint(model.summary())\n```\n\n### Time Series Analysis\nTime series analysis allows us to explore how the relationship between GII and GDP change vary across different time periods, accounting for lagged effects. \n\nHere was a quick summary of the result:\n* Both GII and GDP change time series were stationary.\n\n* Past GII change values significantly influenced cuurent GII change values.\n\n* VAR model had good model performance on forecasting future values based on historical data. \n\n* Changes in GDP did not cause/precde the changes in GII. \n\n#### ADF Test: Stationality Assumption Check\nWe wanted to use Augmented Dickey-Fuller (ADF) test to check whether a time series was stationary, which was the model assumption for many time series models. \n\nStationarity implied constant mean and variance over time, making it more predictable and stable for forecasting. \n\nBased on the ADF test output, both GII and GDP change time series were stationary. We proceeded to the time series modeling section. \n```{python}\n# Augmented Dickey-Fuller (ADF) test for stationarity check\n# Create melted datasets\ncombined_data_time = combined_data.melt(id_vars=['Time', 'Country'], value_vars=['GII_change','GDP_change'], var_name = 'Change_Type', value_name = 'Value')\nGII = combined_data_time[(combined_data_time['Change_Type'] == 'GII_change')]                         \n\nGDP = combined_data_time[(combined_data_time['Change_Type'] == 'GDP_change')]\n\n# Stationary Check\ndef adf_test(series):\n    result = adfuller(series.dropna())\n    print(f'ADF Statistic: {result[0]}')\n    print(f'p-value: {result[1]}')\n    if result[1] < 0.05:\n        print(\"Series is stationary\")\n    else:\n        print(\"Series is not stationary\")\n\n# Output the result\nadf_test(GII['Value'])\nadf_test(GDP['Value'])\n```\n\n#### VAR model: Examine variables separately\nWe fitted a VAR (Vector Autoreression) model to see the relationship between GII and GDP change. VAR is particularly useful when dealing with multivariate time series data and allows us to examine the interdependence between variables. \n\nBased on summary, here were several interpretations we could make:\n\n* We used AIC as the criteria for model selection. Lower value suggests a better fit. \n\n* Given that we wanted to predict GII change, we focused on the first set \"Results for equation GII_change.\"\n\n* Past GII_change values significantly influenced current GII_change, as shown in the small p-values of lags 1 and 2. \n\n* Lag 2 of GDP_change had a relatively low p-value but is not statistically significant.\n\n```{python}\n# Split the dataset into training and testing sets\nsplit_ratio = 0.7\nsplit_index = int(len(combined_data) * split_ratio)\n\n# Training set is used to fit the model\ntrain_data = combined_data.iloc[:split_index]\n\n# Testing set is used for validation\ntest_data = combined_data.iloc[split_index:]\n\nprint(f\"Training data: {train_data.shape}\")\nprint(f\"Test data: {test_data.shape}\")\n```\n\n```{python}\n# Fit a VAR model \ntime_model = VAR(train_data[['GII_change', 'GDP_change']])\ntime_model_fitted = time_model.fit(maxlags = 15, ic=\"aic\")\n\n# Print out the model summary\nprint(time_model_fitted.summary())\n```\n\n#### VAR Model: Forecasting\nWe applied the model learned above to the test data. Based on the plot, the forecast values seem to follow the actual data well, indicating a good model fit caputuring the underlying trends.\n```{python}\n# Number of steps to forecast (length of the test set)\nn_steps = len(test_data)\n\n# Get the last values from the training set for forecasting\nforecast_input = train_data[['GII_change', 'GDP_change']].values[-time_model_fitted.k_ar:]\n\n# Forecasting\nforecast = time_model_fitted.forecast(y=forecast_input, steps=n_steps)\n\n# Create a DataFrame for the forecasted values\nforecast_df = pd.DataFrame(forecast, index=test_data.index, columns=['GII_forecast', 'GDP_forecast'])\n\n# Ensure the index of the forecast_df matches the test_data index\nforecast_df.index = test_data.index\n```\n\n```{python}\nplt.figure(figsize=(12, 6))\nplt.plot(train_data['GII_change'], label='Training GII', color='blue')\nplt.plot(test_data['GII_change'], label='Actual GII', color='orange')\nplt.plot(forecast_df['GII_forecast'], label='Forecasted GII', color='green')\nplt.title('GII Change Forecast vs Actual')\nplt.legend()\nplt.show()\n\nplt.figure(figsize=(12, 6))\nplt.plot(train_data['GDP_change'], label='Training GDP', color='blue')\nplt.plot(test_data['GDP_change'], label='Actual GDP', color='orange')\nplt.plot(forecast_df['GDP_forecast'], label='Forecasted GDP', color='green')\nplt.title('GDP Change Forecast vs Actual')\nplt.legend()\nplt.show()\n```\n\n#### VAR Model: Model Performance\nLow values of both MAE and RMSE indicate good model performance with small average errors in predictions. \n```{python}\nmae_gii = mean_absolute_error(test_data['GII_change'], forecast_df['GII_forecast'])\nmae_gdp = mean_absolute_error(test_data['GDP_change'], forecast_df['GDP_forecast'])\n\nprint(f'Mean Absolute Error for GII: {mae_gii}')\nprint(f'Mean Absolute Error for GDP: {mae_gdp}')\n```\n\n\n```{python}\nrmse_gii = np.sqrt(mean_squared_error(test_data['GII_change'], forecast_df['GII_forecast']))\nrmse_gdp = np.sqrt(mean_squared_error(test_data['GDP_change'], forecast_df['GDP_forecast']))\n\nprint(f'RMSE for GII: {rmse_gii}')\nprint(f'RMSE for GDP: {rmse_gdp}')\n```\n\n#### VAR Model: Granger causality test\nGranger causality test evaluates whether one time series can predict another. \n\nBased on the output, the lowest p-value is when lag = 2. However, because p-value > 0.05, we fail to reject the null hypothesis and conclude the GDP_change does not Granger-cause the GII_change.\n```{python}\n# Perform the Granger causality test\nmax_lag = 3\ntest_result = grangercausalitytests(train_data[['GII_change', 'GDP_change']], max_lag, verbose=True)\n\n```\n\n## Conclusion\nIn wrapping up our analysis, we found no evidence to support a significant relationship between the Change in Real GDP per capita and the Change in the Gender Inequality Index (GII). This suggests that economic growth may not have a direct impact on gender equality. However, our findings open the door to questions for future research. Check out the blog for full analysis!\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"output-file":"imfp_demo.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.33","theme":"cosmo","title":"imfp Demo Project"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}